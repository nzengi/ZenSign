# NzengiCrypt: Provably Secure Partially Blind Signature Scheme

NzengiCrypt is an implementation of the **Provably Secure Partially Blind Signature Scheme** based on the paper by Masayuki Abe and Tatsuaki Okamoto. This scheme combines privacy and verification, allowing certain information to remain hidden while ensuring other information can be verified.

This project can be used for cryptographic protocols focused on privacy, such as digital payment systems, e-voting, and any other applications where anonymity is essential.

## Project Structure

NzengiCrypt is built with a modular design, consisting of the following files and modules:

- **math_helpers.py**: Contains mathematical helper functions, random number generation, and primality tests.
- **dsa_helpers.py**: Handles DSA parameter selection and key pair generation.
- **hash_helpers.py**: Provides hash functions and full domain hash implementations.
- **protocol.py**: Implements the core signature protocol with `Signer` and `User` classes.
- **check_signature.py**: Verifies the signatures generated by the protocol.

## Key Concepts and Mathematical Formulas

### 1. **Partially Blind Signature**
   - A partially blind signature allows a signer to sign a message while keeping some parts of the information hidden. This is particularly useful in applications where privacy is needed but certain verifiable information must still be attached to the signature.

### 2. **DSA (Digital Signature Algorithm) Parameters**
   - **p**: A prime number such that \( p - 1 \) is divisible by \( q \).
   - **q**: A prime divisor of \( p - 1 \).
   - **g**: A generator of the subgroup of order \( q \) in the multiplicative group of integers modulo \( p \).
   - These parameters are selected using a combination of cryptographic randomness and primality tests.

### 3. **Mathematical Formulas**
   - **Signature Generation**:
     - The signer computes two values \( a \) and \( b \), where:
       \[
       a = g^u \mod p
       \]
       \[
       b = g^s \cdot z^d \mod p
       \]
       \( u, s, d \) are random values, and \( z \) is derived from hashing the info.
     - After receiving the challenge \( e \) from the user, the signer computes:
       \[
       c = (e - d) \mod q
       \]
       \[
       r = (u - c \cdot x) \mod q
       \]
       \( x \) is the private key of the signer.
   
   - **Signature Verification**:
     - The user computes four values: \( \rho, \omega, \delta, \sigma \). The signature is valid if the following equation holds:
       \[
       \text{hash}((g^\rho \cdot y^\omega \mod p), (g^\delta \cdot z^\sigma \mod p), z, \text{msg}) \mod q = (\omega + \sigma) \mod q
       \]

### 4. **Full Domain Hash (FDH)**
   - The full domain hash function spreads the hash values uniformly across a larger domain, ensuring cryptographic security.
   - This project uses SHA-256 as the underlying hash function.

## Usage

1. **Signer**: The signer generates a signature for the user using partially blind signature protocols.
2. **User**: The user interacts with the signer, receiving the partially blind signature and verifying it.

### Example

Here is a simple example of how to use the `NzengiCrypt` modules:

```python
from dsa_helpers import choose_parameters
from protocol import Signer, User
from check_signature import check

L, N = 1024, 160
info = b'info'
msg = b'my msg'

params = choose_parameters(L, N)
signer = Signer(params)
signer.start(info)

user = User(params, signer.keypair['y'])
user.start(info, msg)

a, b = signer.one()
e = user.two(a, b)
r, c, s, d = signer.three(e)
rho, omega, delta, sigma = user.four(r, c, s, d)

assert check(rho, omega, delta, sigma, user.z, msg, user.y, params)
```

S00N-2
